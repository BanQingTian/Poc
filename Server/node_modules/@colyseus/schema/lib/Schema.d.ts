import { Definition, FilterCallback, Client, Context } from "./annotations";
import * as decode from "./encoding/decode";
import { ChangeTree } from "./ChangeTree";
import { NonFunctionPropNames } from './types/HelperTypes';
import { EventEmitter } from './events/EventEmitter';
export interface DataChange<T = any> {
    field: string;
    value: T;
    previousValue: T;
}
/**
 * Schema encoder / decoder
 */
export declare abstract class Schema {
    static _typeid: number;
    static _context: Context;
    static _schema: Definition;
    static _indexes: {
        [field: string]: number;
    };
    static _fieldsByIndex: {
        [index: number]: string;
    };
    static _filters: {
        [field: string]: FilterCallback;
    };
    static _deprecated: {
        [field: string]: boolean;
    };
    static _descriptors: PropertyDescriptorMap & ThisType<any>;
    static onError(e: any): void;
    protected $changes: ChangeTree;
    protected $listeners: {
        [field: string]: EventEmitter<(a: any, b: any) => void>;
    };
    onChange?(changes: DataChange[]): any;
    onRemove?(): any;
    constructor(...args: any[]);
    protected readonly _schema: Definition;
    protected readonly _descriptors: PropertyDescriptorMap & ThisType<any>;
    protected readonly _indexes: {
        [field: string]: number;
    };
    protected readonly _fieldsByIndex: {
        [index: number]: string;
    };
    protected readonly _filters: {
        [field: string]: FilterCallback<any, any, any>;
    };
    protected readonly _deprecated: {
        [field: string]: boolean;
    };
    readonly $changed: boolean;
    listen<K extends NonFunctionPropNames<this>>(attr: K, callback: (value: this[K], previousValue: this[K]) => void): () => void;
    decode(bytes: any, it?: decode.Iterator): this;
    encode(root?: Schema, encodeAll?: boolean, client?: Client, bytes?: number[]): number[];
    encodeFiltered(client: Client, bytes?: number[]): number[];
    encodeAll(bytes?: number[]): number[];
    encodeAllFiltered(client: Client, bytes?: number[]): number[];
    clone(): any;
    triggerAll(): void;
    toJSON(): {};
    discardAllChanges(): void;
    private _encodeEndOfStructure;
    private tryEncodeTypeId;
    private createTypeInstance;
    private _triggerChanges;
}
